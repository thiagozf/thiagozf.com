---
title: How I Built My Blog
description: Astro, Tailwind and Cloudflare for a free, fast and no bullshit blog
author: thiagozf
date: 2025-01-26
tags:
  - webdev
  - opinion
---

import Tweet from '@/components/Tweet.astro'

## Introduction

In my last post, I shared why [I finally started a blog](/blog/i-finally-started-a-blog)
as a developer. Over the years, I’ve encountered my fair share of frustrating
platforms — clunky interfaces, slow load times, and features that seemed
designed to annoy rather than help. Those experiences shaped what I wanted for
my own blog, so I set a few key principles to guide this project:

- **Freedom:** I wanted full control over the content, design, and
  functionality, without being locked into someone else’s platform or rules.
- **Developer Experience (DX):** Writing and publishing should feel effortless.
- **Simplicity:** The blog should be clean and easy to navigate, without
  unnecessary clutter.
- **Performance:** Fast loading times and smooth interactions are a must.
- **Privacy-first:** No invasive tracking of personal information — just a
  straightforward, respectful experience for readers.

With these goals in mind, I carefully chose a set of tools and technologies
to build this blog. Each decision was intentional, aimed at creating something
that works well and feels good to use. Let’s take a closer look at the tech
stack and how it all comes together!

## Inspirations

The principles listed above were heavily inspired by projects like [Bear](https://bearblog.dev/),
a _privacy-first, no-nonsense, super-fast blogging platform_. I seriously
considered using Bear, but Freedom — having full control over my content and
design — was non-negotiable for me.

When it came to the UI, Glance perfectly captured the modern, clean, minimalist
aesthetic I wanted. I also found inspiration in other platforms and tools that
share this philosophy, like the [Supreme](https://supreme.com/) website, which
nails that bold, no-frills design.

Despite all these great examples, I couldn’t find a platform that ticked all
the boxes for me. So, I decided to roll up my sleeves and build something tailored
to my needs.

## Tech Stack

To build this blog, I’ve carefully selected a curated set of tools that prioritize
simplicity, performance, and developer experience:

- [Astro](https://astro.build/): A static site generator that’s perfect for
  markdown-focused content. It’s lightweight, fast, and keeps things straightforward.
- [Tailwind CSS](https://tailwindcss.com/)  A utility-first CSS framework that makes
  styling ergonomic and efficient, without the overhead of traditional CSS.
- [Bun](https://bun.sh/) A blazing-fast runtime and package manager that speeds up
  development and reduces friction in the build process.
- [Cloudflare Pages](https://pages.cloudflare.com/) A hassle-free hosting solution
  that’s simple to set up and delivers excellent performance.

Each tool was chosen with the blog’s ethos in mind: no bloat, no unnecessary
complexity. Now, let’s dive deeper into each tool and explore why it made the cut,
how it fits into the overall architecture, and what makes it stand out. We’ll
start with Astro and work our way through the stack.

### Astro: Content-First by Default

Astro stood out as the perfect static site generator for this project. Being
content focused, it revolves around native Markdown support. Writing posts is
as simple as creating a Markdown file with some frontmatter for metadata.
Astro handles the rest, transforming it into a fully optimized and styled
static page.

That is another key feature of Astro: delivering content with minimal overhead,
which is exactly what I wanted.

<Tweet
  src="https://x.com/thiagozf/status/1881717522350899549"
  media="https://pbs.twimg.com/media/Gh0z4aAWkAACuYJ?format=jpg&name=small"
  date="Jan 21, 2025"
>
  yay i did it
</Tweet>

Astro achieves this by shipping **zero JavaScript by default**. Unlike
traditional frameworks that bundle JavaScript for every page, Astro only
includes JavaScript when explicitly needed, using a technique called “islands
architecture.” This means the blog is fast and lightweight, even on slower
connections.

Finally, Astro comes with built-in optimizations like automatic image
compression, HTML minification, and lazy loading. These features ensure that
the blog not only looks good but also **performs exceptionally well**.

### Tailwind CSS: Styling Without the Bloat

Styling a blog can quickly become a headache if you’re not careful. Traditional
CSS frameworks often come with a lot of bloat, and writing custom CSS can be
time-consuming. That’s where Tailwind CSS comes in.

Tailwind takes a utility-first approach, meaning you style elements by applying
small, reusable classes directly in your HTML. This eliminates the need for
custom CSS files and keeps your styles tightly coupled with your markup.

One of Tailwind’s best features is its purge capability. In production builds,
Tailwind automatically removes any unused CSS classes, resulting in a tiny
stylesheet. This is crucial for keeping the blog lightweight and fast.

### Bun: Fast All-in-One JS Toolkit

When it came to managing dependencies and running builds, I wanted something
fast and modern. Enter Bun, a runtime and toolkit designed to replace Node.js
and npm.

Bun’s speed is its standout feature. Installing dependencies with Bun is way
faster than with other package managers, and builds complete in a fraction of
the time. This is a game-changer for a blog that’s rebuilt and redeployed with
every update.

But Bun isn’t just fast — it’s also incredibly convenient. It combines the
functionality of a package manager, bundler, and runtime into a single
executable. This means no more juggling between npm, Webpack, and Babel. Bun
handles it all, with built-in TypeScript support and a streamlined developer
experience.

For a project like this, where simplicity and speed are paramount, Bun was the
perfect choice.

### Cloudflare Pages: Hosting with Ease

Hosting was another critical decision. I wanted a platform that was fast,
reliable and secure. Cloudflare Pages checked all the boxes.

Cloudflare Pages offers global CDN hosting, meaning content is served from the
nearest edge location to the reader. This ensures fast load times no matter
where your audience is located.

Deploying the blog is also a breeze. Every time I push changes to GitHub,
Cloudflare Pages automatically rebuilds and deploys the site. It’s a seamless
process that lets me focus on writing rather than managing infrastructure.

## The Starting Point: astro-erudite

Once I decided the tech stack, the next step was finding a solid reference to
build upon. While I wanted to create something unique, I also didn’t want to
start completely from scratch. That’s when I stumbled upon
[astro-erudite](https://github.com/jktrn/astro-erudite),
a minimalist Astro blog template that felt like it was made for this project.

astro-erudite is a beautifully crafted template by [enscribe](https://enscribe.dev/)
([jktrn](https://github.com/jktrn) on GitHub). It checked almost every box I had in mind:

- **Clean and simple design:** The layout is distraction-free, readable, and
elegant—exactly what I wanted for a content-focused blog.
- **Tailwind CSS:** The utility-first approach keeps styling minimal and maintainable.
  It also includes [Tailwind Typography](https://github.com/tailwindlabs/tailwindcss-typography),
  which ensures content is automatically formatted for readability.
- **Syntax highlighting:** It uses [Shiki](https://github.com/shikijs/shiki),
  a lightweight and visually appealing   solution for code snippets — a
  must-have for any developer blog.
- **No fluff:** Every feature feels intentional, with no unnecessary bloat or
  over-engineering.

The template also came with a strong set of built-in features, including:

- A clean, content-first layout.
- An RSS feed for readers who prefer to follow along that way.
- SEO optimizations, like Open Graph tags, to make sharing posts seamless.
- Semantic HTML for better accessibility and structure.

It was the perfect foundation: simple, elegant, and purpose-driven. All it needed
was a few personal tweaks to make it truly mine.

## The Changes

While astro-erudite was a great starting point, I made some changes to better
align with my vision.

### Switch to Bun

The template originally used npm as the package manager. I replaced it with Bun
for faster installs and builds. Bun’s speed and all-in-one toolkit (package
manager, bundler, and runtime) made the development process smoother and more
efficient.

That was an easy one: you just need to remove the `package-lock.json` lock file
and run `bun install{:sh}` to generate a new lock file. For good measure, you can
also modify the `package.json` and set Bun as the `packageManager`.

```json title="package.json" showLineNumbers
{
  "name": "thiagozf",
  "type": "module",
  "version": "1.2.4",
  "private": true,
  "packageManager": "bun@1.1.20", /* [!code ++] */
  "engines": { /* [!code ++] */
    "bun": ">1.1.20" /* [!code ++] */
  }, /* [!code ++] */
  "scripts": {}
}
```

### Ditch shadcn

The template uses [shadcn](https://github.com/shadcn-ui/ui) UI
elements, like Avatar and Button. Since these components are very simple,
I've decided to rewrite them as Astro components, reducing the dependencies
of the project (_hasta la vista_, React).

For reference, here is the equivalent Avatar component using Astro.

```astro
---
import { cn } from '@/lib/utils'
import { Image } from 'astro:assets'
import logo from '../../public/static/logo.png'

type Props = {
  src?: ImageMetadata
  width: number
  height: number
  alt?: string
  class?: string
}

const { src = logo, alt = 'Avatar', class: className, ...props } = Astro.props
---

<div
  class={cn(
    'relative flex h-10 w-10 shrink-0 overflow-hidden rounded-full',
    className,
  )}
>
  <Image {...props} class="aspect-square h-full w-full" src={src} alt={alt} />
</div>
```
However, I preserved the semantic convention involving CSS colors, such as
`background` and `foreground` into the Tailwind configuration, since it makes
styling a breeze. Other utility colors such as `primary`, `secondary`, `muted`,
`accent`, and `destructive` also exist and are very self-explanatory.

**Example:** shadcn/ui convention turns 
`"bg-stone-50 text-stone-900 dark:bg-stone-900 dark:text-stone-50"`
into `"bg-background text-foreground"`, which is both more semantic and easier
to edit — if I want to change my blog's theme, I don't need to go around
every component and change its classes, instead I just edit a single CSS
variable.

I also kept the `cn(){:ts}` utility function, which combines [clsx](https://www.npmjs.com/package/clsx)
and [tailwind-merge](https://www.npmjs.com/package/tailwind-merge), two packages
which allow painless conditional class addition and concatenation:

```tsx title="src/lib/utils.ts" showLineNumbers
  import { type ClassValue, clsx } from 'clsx'
  import { twMerge } from 'tailwind-merge'

  export function cn(...inputs: ClassValue[]) {
    return twMerge(clsx(inputs))
  }
```

This serves two purposes:

1. Safely concatenate whatever customizations are passed via the
   `class` prop to a base components.
2. Improve the DX, automatically handling class merges and making
   conditional styles easy to implement.

I also customized the Tailwind’s theme to match the clean, minimalist
aesthetic I was going for. The result is a blog that’s visually simple,
with plenty of whitespace and no distractions.

My main inspiration was [Glance](https://github.com/glanceapp/glance),
a self-hosted dashboard that I use to aggregate feeds. I highly recommend
you to check it out!

### Add Simple Analytics

While I wanted to avoid invasive tracking, I also need some basic insights
to understand visitor behavior. If my audience enjoys reading about AI,
for example, I can focus on writing content about it rather than topics
that are not relevant for them.

[Simple Analytics](https://www.simpleanalytics.com/) is a privacy-friendly and
simple alternative to Google Analytics. It is free, privacy-focused,
GDPR-compliant, and doesn’t use cookies or trackers.

It was the perfect solution for me. Now I can use a single dashboard to
instantly see how many visitors are coming to my blog, where they are coming
from and what they are interested at once they're here.

One big plus is that the installation script is very lightweight — less
than 4kb, compared to **371kb** from `gtag.js` —, so it barely impacts the
site's performance metrics.

The installation is quite straightforward: I just need to add their script
to all pages. To do so, create an `Analytics` element and modify
`src/layouts/Layout.astro` to include it:

```astro title="src/components/Analytics.astro" showLineNumbers
---
---

<script
  is:inline
  async
  src="https://scripts.simpleanalyticscdn.com/latest.js">
</script>

<noscript>
  <img
    src="https://queue.simpleanalyticscdn.com/noscript.gif"
    alt=""
    referrerpolicy="no-referrer-when-downgrade"
  />
</noscript>
```

```astro title="src/layouts/Layout.astro"
---
import Analytics from '@/components/Analytics.astro' /* [!code ++] */
import Footer from '@/components/Footer.astro'
import Head from '@/components/Head.astro'
// ...
---

<!doctype html>
<html lang="en">
  <body>
    <!-- ... -->
    <Analytics /> /* [!code ++] */
  </body>
</html>
```

### Integrate an OpenGraph Image Generator

To make shared links more visually appealing, I added an [Open Graph](https://ogp.me/)
image generator. This dynamically creates social media-friendly images
for each post, using the post’s title and metadata.

Since I didn't need anything fancy for now, I've used the [`astro-og-canvas`](https://www.npmjs.com/package/astro-og-canvas/v/0.3.0)
package. It generates OG images with a pre-defined layout, but provides
some level of customization. It is also very straightforward to use:

1. **Create a new `src/pages` file:** this will be the route that generates
   the Open Graph images.
2. **Customize the images**: Use the `OGImageRoute{:ts}` helper to create
   the `getStaticPaths{:ts}` and `GET{:ts}` functions for you.
   You can read more about the available options in the
   [astro-og-canvas documentation](https://github.com/delucis/astro-og-canvas/tree/latest/packages/astro-og-canvas#image-options).

Here is the final code. I'm using the frontmatter metadata to build the
image. I've also added the same font and colors used by the web pages
to keep visual consistency.

```ts title="src/pages/og/[...route].ts" showLineNumbers
import { OGImageRoute } from 'astro-og-canvas'

const pages = import.meta.glob('/src/content/**/*.{md,mdx}', { eager: true })

const newPages = Object.entries(pages).reduce((acc, [path, page]) => {
  const newPath = path.replace('/src/content', '')
  return { ...acc, [newPath]: page }
}, {})

export const { getStaticPaths, GET } = OGImageRoute({
  param: 'route',
  pages: newPages,
  getImageOptions: (_path, page) => ({
    title: page.frontmatter.title || page.frontmatter.name || '',
    description: page.frontmatter.description || '',
    logo: {
      path: './public/static/logo.png',
      size: [124, 124],
    },
    font: {
      title: {
        families: ['JetBrains Mono', 'monospaced'],
        weight: 'Bold',
        color: [250, 250, 250],
      },
      description: {
        families: ['JetBrains Mono', 'monospaced'],
        color: [211, 198, 170],
      },
    },
    fonts: ['./public/fonts/JetBrainsMono[wght].woff2'],
    bgGradient: [[10, 10, 10]],
  }),
})
```

Every post now has an associated image with it at
`/og/blog/${post.id}.png{:bash}`. The image for this blog post,
for example, is [`/og/blog/how-i-built-my-blog.png`](/og/blog/how-i-built-my-blog.png):

<img src="/og/blog/how-i-built-my-blog.png" />

The cool thing is that it also works for other content collections
of the Astro website, like **projects** and **authors**. Here is an
example for the `thiagozf`'s author profile ([`/og/authors/thiagozf.png`](/og/authors/thiagozf.png)):

<img src="/og/authors/thiagozf.png" />

Pretty cool, right?

### Add Structured Data for SEO (JSON-LD)

To improve search engine visibility, I've added [Schema.org](https://schema.org)
[JSON-LD](https://json-ld.org/) structured data to each post. This
helps search engines better understand the content and display rich
snippets in search results.

It is fairly simple to declare schemas in Astro using the
[`astro-seo-schema`](https://www.npmjs.com/package/astro-seo-schema)
package: you just need to import the `<Schema>{:tsx}` component,
that is fully type-safe (it uses TypeScript definitions from
[`schema-dts`](https://www.npmjs.com/package/schema-dts).

This `<Schema>{:tsx}` component:

- Adds type checking to validate user-provided schema JSON
- Escapes the JSON data.
- Outputs a `<script type="type="application/ld+json">{:html}` with the escaped schema.

Here are the relevant parts of the blog post page (`/src/pages/blog/[...id].astro`):

```astro title="src/pages/blog/[...id].astro"
---
import { Schema } from 'astro-seo-schema'  /* [!code ++] */
import { buildPostSchema } from '@/lib/schemas'  /* [!code ++] */

// ...

const schema = buildPostSchema(post, author) /* [!code ++] */
---

<Layout>
  <Schema slot="head" item={schema} />  /* [!code ++] */
  <!-- blog post content -->
</Layout>
```

A utility function `buildPostSchema{:ts}` is used to build the schema.

```ts title="src/lib/schemas.ts"
import { site } from '@/site'
import { type CollectionEntry } from 'astro:content'
import type { BlogPosting, Person, WithContext } from 'schema-dts'
import { getPostImage, getPostURL } from './posts'

const buildAuthorSchema = (author: CollectionEntry<'authors'>): Person => {
  const { id, data } = author
  const { name, email } = data
  const url = new URL(`/authors/${id}`, site.url).href
  const image = new URL(`/og/authors/${id}`, site.url).href
  return {
    '@type': 'Person',
    name,
    url,
    email,
    image,
  }
}

export const buildPostSchema = (
  post: CollectionEntry<'blog'>,
  author: CollectionEntry<'authors'>,
): WithContext<BlogPosting> => {
  const image = getPostImage(post)
  const url = getPostURL(post)
  return {
    '@context': 'https://schema.org',
    '@type': 'BlogPosting',
    author: buildAuthorSchema(author),
    headline: post.data.title,
    datePublished: post.data.date.toISOString(),
    dateCreated: post.data.date.toISOString(),
    description: post.data.description,
    keywords: post.data.tags,
    image,
    url,
  }
}
```

Finally, base schemas describing the website and the page were added
on every page (`/src/components/Head.astro`).

```astro title="src/components/Head.astro"
---
import { site } from '@/site'
import { Schema } from 'astro-seo-schema'

const canonicalURL = new URL(Astro.url.pathname, Astro.site).href
const {
  title,
  description = site.description,
  image = new URL(`/og/projects/${site.project}.png`, Astro.site).href,
} = Astro.props
---

<Schema
  item={{
    '@context': 'https://schema.org',
    '@type': 'WebSite',
    name: site.title,
    description: site.description,
    url: site.url,
  }}
/>

<Schema
  item={{
    '@context': 'https://schema.org',
    '@type': 'WebPage',
    name: title,
    description: description,
    url: canonicalURL,
    image,
  }}
/>
```

## How It All Fits Together

The DX to add a new post is straightforward:

1. Create a Markdown file in the `/src/pages/blog` directory.
2. Write the post using markdown and add frontmatter metadata.
3. Run `bun run dev` to preview the post.
4. Push the changes to GitHub, and Cloudflare Pages handles the rest.

The result is a blog that is blazingly fast, respects reader privacy,
and lets the content shine.

<img src="https://media1.tenor.com/m/Hw0aKasI6B4AAAAd/fast-blazing-fast.gif" />

## Final Thoughts

Building a blog in 2025 doesn’t have to be complicated. By choosing tools that
prioritize simplicity, performance, and privacy, I’ve created a platform that’s fast,
lightweight, and easy to maintain.

If you’re inspired to start your own blog, I encourage you to explore the tools I’ve
used. You don’t need a complex setup to create something meaningful. Sometimes, less
really is more!
